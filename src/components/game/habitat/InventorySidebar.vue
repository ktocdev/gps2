<template>
  <div
    class="inventory-sidebar"
    @dragover.prevent="handleDragOver"
    @dragleave="handleDragLeave"
    @drop="handleDrop"
    :class="{ 'inventory-sidebar--drop-target': isDragOver }"
  >
    <h4 class="inventory-sidebar__title">Inventory</h4>
    <div class="inventory-sidebar__items">
      <!-- Serving-based consumables -->
      <InventoryTileServing
        v-for="item in servingBasedItems"
        :key="item.itemId"
        :item-id="item.itemId"
        :name="item.name"
        :emoji="item.emoji"
        :servings-remaining="item.servingsRemaining"
        :max-servings="item.maxServings"
        :instance-count="item.instanceCount"
        @dragstart="(_itemId, event) => handleServingDragStart(event, item)"
        @dragend="handleDragEnd"
      />

      <!-- Regular habitat items and food -->
      <div
        v-for="item in regularItems"
        :key="item.id"
        class="inventory-sidebar__item-card"
        draggable="true"
        @dragstart="handleDragStart($event, item)"
        @dragend="handleDragEnd"
      >
        <span class="inventory-sidebar__item-emoji">{{ item.emoji }}</span>
        <span class="inventory-sidebar__item-name">{{ item.name }}</span>
        <span v-if="item.availableCount > 1" class="inventory-sidebar__item-count">Ã—{{ item.availableCount }}</span>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { useHabitatConditions } from '../../../stores/habitatConditions'
import { useInventoryStore } from '../../../stores/inventoryStore'
import { useSuppliesStore } from '../../../stores/suppliesStore'
import InventoryTileServing from '../shop/InventoryTileServing.vue'

interface Props {
  habitatVisualRef?: any
}

const props = defineProps<Props>()

const habitat = useHabitatConditions()
const inventoryStore = useInventoryStore()
const suppliesStore = useSuppliesStore()

const isDragOver = ref(false)

// Serving-based consumables (hay, lettuce, carrots)
const servingBasedItems = computed(() => {
  return inventoryStore.items
    .filter(invItem => {
      const item = suppliesStore.getItemById(invItem.itemId)
      // Only show items with serving metadata
      return item?.stats?.servings !== undefined
    })
    .map(invItem => {
      const item = suppliesStore.getItemById(invItem.itemId)
      // Filter instances with servings remaining
      const availableInstances = invItem.instances.filter(
        inst => inst.servingsRemaining !== undefined && inst.servingsRemaining > 0
      )

      // Use first instance for display, but show count of all instances
      const firstInstance = availableInstances[0]

      return {
        instanceId: firstInstance?.instanceId || '',
        itemId: invItem.itemId,
        name: item?.name || 'Unknown',
        emoji: item?.emoji || 'ðŸ“¦',
        servingsRemaining: firstInstance?.servingsRemaining || 0,
        maxServings: firstInstance?.maxServings || 0,
        instanceCount: availableInstances.length
      }
    })
    .filter(item => item.instanceCount > 0) // Only show if at least one instance exists
})

// Regular habitat items and non-serving food
const regularItems = computed(() => {
  return inventoryStore.items
    .filter(invItem => {
      const item = suppliesStore.getItemById(invItem.itemId)
      // Show habitat items and food WITHOUT serving metadata
      const isPlaceable = item?.category === 'habitat_item' || item?.category === 'food'
      const hasNoServings = item?.stats?.servings === undefined
      return isPlaceable && hasNoServings
    })
    .map(invItem => {
      const item = suppliesStore.getItemById(invItem.itemId)
      // Count how many are in habitat vs available
      const inHabitatCount = habitat.habitatItems.filter((id: string) => id === invItem.itemId).length
      const availableCount = invItem.quantity - inHabitatCount

      return {
        id: invItem.itemId,
        name: item?.name || 'Unknown',
        emoji: item?.emoji || 'ðŸ“¦',
        size: getItemSize(item),
        quantity: invItem.quantity,
        availableCount
      }
    })
    .filter(item => item.availableCount > 0) // Only show if at least one is available
})

function getItemSize(item: any): { width: number; height: number } {
  const size = item.stats?.size
  if (size === 'small') return { width: 1, height: 1 }
  if (size === 'medium') return { width: 2, height: 1 }
  if (size === 'large') return { width: 2, height: 2 }
  return { width: 1, height: 1 }
}

// Drag handlers
function handleServingDragStart(event: DragEvent, item: any) {
  if (!event.dataTransfer) return

  // Get item category for drag validation
  const suppliesItem = suppliesStore.getItemById(item.itemId)
  const category = suppliesItem?.category || 'unknown'

  // Store serving data for drop handler
  const dragData = {
    itemId: item.itemId,
    instanceId: item.instanceId,
    isServingBased: true,
    size: { width: 1, height: 1 } // Servings are always 1x1
  }

  event.dataTransfer.effectAllowed = 'move'
  event.dataTransfer.setData('text/plain', JSON.stringify(dragData))
  // Add category as custom MIME type so we can check it during dragover
  event.dataTransfer.setData(`application/x-item-category-${category}`, '')

  // Notify HabitatVisual about the drag
  if (props.habitatVisualRef) {
    props.habitatVisualRef.setDraggedItem(item.itemId, { width: 1, height: 1 })
  }
}

function handleDragStart(event: DragEvent, item: any) {
  if (!event.dataTransfer) return

  // Get item category for drag validation
  const suppliesItem = suppliesStore.getItemById(item.id)
  const category = suppliesItem?.category || 'unknown'

  // Store item data for drop handler
  const dragData = {
    itemId: item.id,
    size: item.size
  }

  event.dataTransfer.effectAllowed = 'move'
  event.dataTransfer.setData('text/plain', JSON.stringify(dragData))
  // Add category as custom MIME type so we can check it during dragover
  event.dataTransfer.setData(`application/x-item-category-${category}`, '')

  // Notify HabitatVisual about the drag
  if (props.habitatVisualRef) {
    props.habitatVisualRef.setDraggedItem(item.id, item.size)
  }

  // Visual feedback
  const target = event.target as HTMLElement
  target.style.opacity = '0.5'
}

function handleDragEnd(event: DragEvent) {
  const target = event.target as HTMLElement
  target.style.opacity = '1'

  // Clear dragged item
  if (props.habitatVisualRef) {
    props.habitatVisualRef.clearDraggedItem()
  }
}

// Inventory drop zone handlers
function handleDragOver(event: DragEvent) {
  event.preventDefault()
  isDragOver.value = true

  if (event.dataTransfer) {
    event.dataTransfer.dropEffect = 'move'
  }
}

function handleDragLeave() {
  isDragOver.value = false
}

function handleDrop(event: DragEvent) {
  event.preventDefault()
  isDragOver.value = false

  const itemData = event.dataTransfer?.getData('text/plain')
  if (!itemData) return

  try {
    const data = JSON.parse(itemData)
    const itemId = data.itemId
    const isRepos = data.isRepositioning || false

    // Only handle items being dragged FROM the habitat (repositioning = true)
    if (!isRepos) {
      console.log('Item is from inventory, not habitat. Ignoring drop.')
      return
    }

    // Check if item is a bowl or hay rack with contents
    const isBowl = itemId.includes('bowl') || itemId.includes('dish')
    const isHayRack = itemId.includes('hay_rack')

    if (isBowl && habitat.getBowlContents(itemId).length > 0) {
      console.warn('Cannot remove bowl with food. Clear it first.')
      return
    }

    if (isHayRack && habitat.getHayRackContents(itemId).length > 0) {
      console.warn('Cannot remove hay rack with hay. Clear it first.')
      return
    }

    // Remove item from habitat and return to inventory
    const success = habitat.removeItemFromHabitat(itemId)
    if (success) {
      console.log(`Removed ${itemId} from habitat and returned to inventory`)
    }
  } catch (e) {
    console.error('Error parsing drag data:', e)
  }
}
</script>

<style>
.inventory-sidebar {
  inline-size: 140px;
  flex-shrink: 0;
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
  background: rgba(0, 0, 0, 0.08);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--space-3);
  box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.15);
  align-self: stretch;
  transition: background 0.2s ease, border-color 0.2s ease;
}

.inventory-sidebar--drop-target {
  background: rgba(16, 185, 129, 0.15);
  border-color: var(--color-success);
  box-shadow: inset 0 2px 8px rgba(16, 185, 129, 0.2), 0 0 0 2px var(--color-success);
}

.inventory-sidebar__title {
  margin: 0;
  font-size: var(--font-size-sm);
  font-weight: var(--font-weight-semibold);
  color: var(--color-text-secondary);
  text-align: center;
  padding-block-end: var(--space-2);
  border-block-end: 1px solid var(--color-border);
  margin-block-end: var(--space-1);
}

.inventory-sidebar__items {
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
  max-block-size: 800px;
  overflow-y: auto;
  padding-block-start: var(--space-1);
  padding-inline-end: var(--space-2);
  margin-inline-end: calc(var(--space-2) * -1);
}

.inventory-sidebar__items::-webkit-scrollbar {
  inline-size: 6px;
}

.inventory-sidebar__items::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.1);
  border-radius: var(--radius-full);
}

.inventory-sidebar__items::-webkit-scrollbar-thumb {
  background: var(--color-primary);
  border-radius: var(--radius-full);
}

.inventory-sidebar__items::-webkit-scrollbar-thumb:hover {
  background: var(--color-primary-hover);
}

.inventory-sidebar__item-card {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--space-2);
  padding: var(--space-3);
  background-color: var(--color-bg-tertiary);
  border-radius: var(--radius-md);
  border: 2px solid var(--color-border);
  cursor: grab;
  transition: all 0.2s ease;
}

.inventory-sidebar__item-card:hover {
  border-color: var(--color-primary);
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.inventory-sidebar__item-card:active {
  cursor: grabbing;
}

.inventory-sidebar__item-emoji {
  font-size: var(--font-size-3xl);
}

.inventory-sidebar__item-name {
  font-size: var(--font-size-xs);
  text-align: center;
  font-weight: var(--font-weight-medium);
}

.inventory-sidebar__item-count {
  position: absolute;
  inset-block-start: var(--space-1);
  inset-inline-end: var(--space-1);
  background-color: var(--color-primary);
  color: var(--color-text-inverse);
  font-size: var(--font-size-xs);
  font-weight: var(--font-weight-bold);
  padding: 2px 6px;
  border-radius: var(--radius-full);
  line-height: 1;
  box-shadow: var(--shadow-sm);
}
</style>
